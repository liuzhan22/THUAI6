// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message2Server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Message2Server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Message2Server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "MessageType.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Message2Server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
    class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Message2Server_2eproto
{
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Message2Server_2eproto;
namespace protobuf
{
    class AttackMsg;
    struct AttackMsgDefaultTypeInternal;
    extern AttackMsgDefaultTypeInternal _AttackMsg_default_instance_;
    class IDMsg;
    struct IDMsgDefaultTypeInternal;
    extern IDMsgDefaultTypeInternal _IDMsg_default_instance_;
    class MoveMsg;
    struct MoveMsgDefaultTypeInternal;
    extern MoveMsgDefaultTypeInternal _MoveMsg_default_instance_;
    class PlayerMsg;
    struct PlayerMsgDefaultTypeInternal;
    extern PlayerMsgDefaultTypeInternal _PlayerMsg_default_instance_;
    class PropMsg;
    struct PropMsgDefaultTypeInternal;
    extern PropMsgDefaultTypeInternal _PropMsg_default_instance_;
    class SendMsg;
    struct SendMsgDefaultTypeInternal;
    extern SendMsgDefaultTypeInternal _SendMsg_default_instance_;
    class SkillMsg;
    struct SkillMsgDefaultTypeInternal;
    extern SkillMsgDefaultTypeInternal _SkillMsg_default_instance_;
    class TreatAndRescueMsg;
    struct TreatAndRescueMsgDefaultTypeInternal;
    extern TreatAndRescueMsgDefaultTypeInternal _TreatAndRescueMsg_default_instance_;
}  // namespace protobuf
PROTOBUF_NAMESPACE_OPEN
template<>
::protobuf::AttackMsg* Arena::CreateMaybeMessage<::protobuf::AttackMsg>(Arena*);
template<>
::protobuf::IDMsg* Arena::CreateMaybeMessage<::protobuf::IDMsg>(Arena*);
template<>
::protobuf::MoveMsg* Arena::CreateMaybeMessage<::protobuf::MoveMsg>(Arena*);
template<>
::protobuf::PlayerMsg* Arena::CreateMaybeMessage<::protobuf::PlayerMsg>(Arena*);
template<>
::protobuf::PropMsg* Arena::CreateMaybeMessage<::protobuf::PropMsg>(Arena*);
template<>
::protobuf::SendMsg* Arena::CreateMaybeMessage<::protobuf::SendMsg>(Arena*);
template<>
::protobuf::SkillMsg* Arena::CreateMaybeMessage<::protobuf::SkillMsg>(Arena*);
template<>
::protobuf::TreatAndRescueMsg* Arena::CreateMaybeMessage<::protobuf::TreatAndRescueMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf
{

    // ===================================================================

    class PlayerMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.PlayerMsg) */
    {
    public:
        inline PlayerMsg() :
            PlayerMsg(nullptr)
        {
        }
        ~PlayerMsg() override;
        explicit PROTOBUF_CONSTEXPR PlayerMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        PlayerMsg(const PlayerMsg& from);
        PlayerMsg(PlayerMsg&& from) noexcept
            :
            PlayerMsg()
        {
            *this = ::std::move(from);
        }

        inline PlayerMsg& operator=(const PlayerMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline PlayerMsg& operator=(PlayerMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const PlayerMsg& default_instance()
        {
            return *internal_default_instance();
        }
        enum JobTypeCase
        {
            kStudentType = 2,
            kTrickerType = 3,
            JOB_TYPE_NOT_SET = 0,
        };

        static inline const PlayerMsg* internal_default_instance()
        {
            return reinterpret_cast<const PlayerMsg*>(
                &_PlayerMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            0;

        friend void swap(PlayerMsg& a, PlayerMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(PlayerMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(PlayerMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        PlayerMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<PlayerMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const PlayerMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const PlayerMsg& from)
        {
            PlayerMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(PlayerMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.PlayerMsg";
        }

    protected:
        explicit PlayerMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kPlayerTypeFieldNumber = 4,
            kStudentTypeFieldNumber = 2,
            kTrickerTypeFieldNumber = 3,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // .protobuf.PlayerType player_type = 4;
        void clear_player_type();
        ::protobuf::PlayerType player_type() const;
        void set_player_type(::protobuf::PlayerType value);

    private:
        ::protobuf::PlayerType _internal_player_type() const;
        void _internal_set_player_type(::protobuf::PlayerType value);

    public:
        // .protobuf.StudentType student_type = 2;
        bool has_student_type() const;

    private:
        bool _internal_has_student_type() const;

    public:
        void clear_student_type();
        ::protobuf::StudentType student_type() const;
        void set_student_type(::protobuf::StudentType value);

    private:
        ::protobuf::StudentType _internal_student_type() const;
        void _internal_set_student_type(::protobuf::StudentType value);

    public:
        // .protobuf.TrickerType tricker_type = 3;
        bool has_tricker_type() const;

    private:
        bool _internal_has_tricker_type() const;

    public:
        void clear_tricker_type();
        ::protobuf::TrickerType tricker_type() const;
        void set_tricker_type(::protobuf::TrickerType value);

    private:
        ::protobuf::TrickerType _internal_tricker_type() const;
        void _internal_set_tricker_type(::protobuf::TrickerType value);

    public:
        void clear_job_type();
        JobTypeCase job_type_case() const;
        // @@protoc_insertion_point(class_scope:protobuf.PlayerMsg)

    private:
        class _Internal;
        void set_has_student_type();
        void set_has_tricker_type();

        inline bool has_job_type() const;
        inline void clear_has_job_type();

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            int player_type_;
            union JobTypeUnion
            {
                constexpr JobTypeUnion() :
                    _constinit_{}
                {
                }
                ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
                int student_type_;
                int tricker_type_;
            } job_type_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            uint32_t _oneof_case_[1];
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class MoveMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.MoveMsg) */
    {
    public:
        inline MoveMsg() :
            MoveMsg(nullptr)
        {
        }
        ~MoveMsg() override;
        explicit PROTOBUF_CONSTEXPR MoveMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        MoveMsg(const MoveMsg& from);
        MoveMsg(MoveMsg&& from) noexcept
            :
            MoveMsg()
        {
            *this = ::std::move(from);
        }

        inline MoveMsg& operator=(const MoveMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline MoveMsg& operator=(MoveMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const MoveMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const MoveMsg* internal_default_instance()
        {
            return reinterpret_cast<const MoveMsg*>(
                &_MoveMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            1;

        friend void swap(MoveMsg& a, MoveMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(MoveMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(MoveMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        MoveMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<MoveMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const MoveMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const MoveMsg& from)
        {
            MoveMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(MoveMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.MoveMsg";
        }

    protected:
        explicit MoveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kAngleFieldNumber = 2,
            kTimeInMillisecondsFieldNumber = 3,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // double angle = 2;
        void clear_angle();
        double angle() const;
        void set_angle(double value);

    private:
        double _internal_angle() const;
        void _internal_set_angle(double value);

    public:
        // int64 time_in_milliseconds = 3;
        void clear_time_in_milliseconds();
        int64_t time_in_milliseconds() const;
        void set_time_in_milliseconds(int64_t value);

    private:
        int64_t _internal_time_in_milliseconds() const;
        void _internal_set_time_in_milliseconds(int64_t value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.MoveMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            double angle_;
            int64_t time_in_milliseconds_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class PropMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.PropMsg) */
    {
    public:
        inline PropMsg() :
            PropMsg(nullptr)
        {
        }
        ~PropMsg() override;
        explicit PROTOBUF_CONSTEXPR PropMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        PropMsg(const PropMsg& from);
        PropMsg(PropMsg&& from) noexcept
            :
            PropMsg()
        {
            *this = ::std::move(from);
        }

        inline PropMsg& operator=(const PropMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline PropMsg& operator=(PropMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const PropMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const PropMsg* internal_default_instance()
        {
            return reinterpret_cast<const PropMsg*>(
                &_PropMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            2;

        friend void swap(PropMsg& a, PropMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(PropMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(PropMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        PropMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<PropMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const PropMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const PropMsg& from)
        {
            PropMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(PropMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.PropMsg";
        }

    protected:
        explicit PropMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kPropTypeFieldNumber = 2,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // .protobuf.PropType prop_type = 2;
        void clear_prop_type();
        ::protobuf::PropType prop_type() const;
        void set_prop_type(::protobuf::PropType value);

    private:
        ::protobuf::PropType _internal_prop_type() const;
        void _internal_set_prop_type(::protobuf::PropType value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.PropMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            int prop_type_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class SendMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.SendMsg) */
    {
    public:
        inline SendMsg() :
            SendMsg(nullptr)
        {
        }
        ~SendMsg() override;
        explicit PROTOBUF_CONSTEXPR SendMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        SendMsg(const SendMsg& from);
        SendMsg(SendMsg&& from) noexcept
            :
            SendMsg()
        {
            *this = ::std::move(from);
        }

        inline SendMsg& operator=(const SendMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline SendMsg& operator=(SendMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const SendMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const SendMsg* internal_default_instance()
        {
            return reinterpret_cast<const SendMsg*>(
                &_SendMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            3;

        friend void swap(SendMsg& a, SendMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(SendMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(SendMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        SendMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<SendMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const SendMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const SendMsg& from)
        {
            SendMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(SendMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.SendMsg";
        }

    protected:
        explicit SendMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kMessageFieldNumber = 3,
            kPlayerIdFieldNumber = 1,
            kToPlayerIdFieldNumber = 2,
        };
        // string message = 3;
        void clear_message();
        const std::string& message() const;
        template<typename ArgT0 = const std::string&, typename... ArgT>
        void set_message(ArgT0&& arg0, ArgT... args);
        std::string* mutable_message();
        PROTOBUF_NODISCARD std::string* release_message();
        void set_allocated_message(std::string* message);

    private:
        const std::string& _internal_message() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
        std::string* _internal_mutable_message();

    public:
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // int64 to_player_id = 2;
        void clear_to_player_id();
        int64_t to_player_id() const;
        void set_to_player_id(int64_t value);

    private:
        int64_t _internal_to_player_id() const;
        void _internal_set_to_player_id(int64_t value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.SendMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
            int64_t player_id_;
            int64_t to_player_id_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class AttackMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.AttackMsg) */
    {
    public:
        inline AttackMsg() :
            AttackMsg(nullptr)
        {
        }
        ~AttackMsg() override;
        explicit PROTOBUF_CONSTEXPR AttackMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        AttackMsg(const AttackMsg& from);
        AttackMsg(AttackMsg&& from) noexcept
            :
            AttackMsg()
        {
            *this = ::std::move(from);
        }

        inline AttackMsg& operator=(const AttackMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline AttackMsg& operator=(AttackMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const AttackMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const AttackMsg* internal_default_instance()
        {
            return reinterpret_cast<const AttackMsg*>(
                &_AttackMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            4;

        friend void swap(AttackMsg& a, AttackMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(AttackMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(AttackMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        AttackMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<AttackMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const AttackMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const AttackMsg& from)
        {
            AttackMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(AttackMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.AttackMsg";
        }

    protected:
        explicit AttackMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kAngleFieldNumber = 2,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // double angle = 2;
        void clear_angle();
        double angle() const;
        void set_angle(double value);

    private:
        double _internal_angle() const;
        void _internal_set_angle(double value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.AttackMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            double angle_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class IDMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.IDMsg) */
    {
    public:
        inline IDMsg() :
            IDMsg(nullptr)
        {
        }
        ~IDMsg() override;
        explicit PROTOBUF_CONSTEXPR IDMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        IDMsg(const IDMsg& from);
        IDMsg(IDMsg&& from) noexcept
            :
            IDMsg()
        {
            *this = ::std::move(from);
        }

        inline IDMsg& operator=(const IDMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline IDMsg& operator=(IDMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const IDMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const IDMsg* internal_default_instance()
        {
            return reinterpret_cast<const IDMsg*>(
                &_IDMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            5;

        friend void swap(IDMsg& a, IDMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(IDMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(IDMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        IDMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<IDMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const IDMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const IDMsg& from)
        {
            IDMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(IDMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.IDMsg";
        }

    protected:
        explicit IDMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.IDMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class TreatAndRescueMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.TreatAndRescueMsg) */
    {
    public:
        inline TreatAndRescueMsg() :
            TreatAndRescueMsg(nullptr)
        {
        }
        ~TreatAndRescueMsg() override;
        explicit PROTOBUF_CONSTEXPR TreatAndRescueMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        TreatAndRescueMsg(const TreatAndRescueMsg& from);
        TreatAndRescueMsg(TreatAndRescueMsg&& from) noexcept
            :
            TreatAndRescueMsg()
        {
            *this = ::std::move(from);
        }

        inline TreatAndRescueMsg& operator=(const TreatAndRescueMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline TreatAndRescueMsg& operator=(TreatAndRescueMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const TreatAndRescueMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const TreatAndRescueMsg* internal_default_instance()
        {
            return reinterpret_cast<const TreatAndRescueMsg*>(
                &_TreatAndRescueMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            6;

        friend void swap(TreatAndRescueMsg& a, TreatAndRescueMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(TreatAndRescueMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(TreatAndRescueMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        TreatAndRescueMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<TreatAndRescueMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const TreatAndRescueMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const TreatAndRescueMsg& from)
        {
            TreatAndRescueMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(TreatAndRescueMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.TreatAndRescueMsg";
        }

    protected:
        explicit TreatAndRescueMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kToPlayerIdFieldNumber = 2,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // int64 to_player_id = 2;
        void clear_to_player_id();
        int64_t to_player_id() const;
        void set_to_player_id(int64_t value);

    private:
        int64_t _internal_to_player_id() const;
        void _internal_set_to_player_id(int64_t value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.TreatAndRescueMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            int64_t to_player_id_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // -------------------------------------------------------------------

    class SkillMsg final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.SkillMsg) */
    {
    public:
        inline SkillMsg() :
            SkillMsg(nullptr)
        {
        }
        ~SkillMsg() override;
        explicit PROTOBUF_CONSTEXPR SkillMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        SkillMsg(const SkillMsg& from);
        SkillMsg(SkillMsg&& from) noexcept
            :
            SkillMsg()
        {
            *this = ::std::move(from);
        }

        inline SkillMsg& operator=(const SkillMsg& from)
        {
            CopyFrom(from);
            return *this;
        }
        inline SkillMsg& operator=(SkillMsg&& from) noexcept
        {
            if (this == &from)
                return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
            )
            {
                InternalSwap(&from);
            }
            else
            {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
        {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
        {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
        {
            return default_instance().GetMetadata().reflection;
        }
        static const SkillMsg& default_instance()
        {
            return *internal_default_instance();
        }
        static inline const SkillMsg* internal_default_instance()
        {
            return reinterpret_cast<const SkillMsg*>(
                &_SkillMsg_default_instance_
            );
        }
        static constexpr int kIndexInFileMessages =
            7;

        friend void swap(SkillMsg& a, SkillMsg& b)
        {
            a.Swap(&b);
        }
        inline void Swap(SkillMsg* other)
        {
            if (other == this)
                return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena())
            {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena())
            {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else
            {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
        }
        void UnsafeArenaSwap(SkillMsg* other)
        {
            if (other == this)
                return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        SkillMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
        {
            return CreateMaybeMessage<SkillMsg>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const SkillMsg& from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const SkillMsg& from)
        {
            SkillMsg::MergeImpl(*this, from);
        }

    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream
        ) const final;
        int GetCachedSize() const final
        {
            return _impl_._cached_size_.Get();
        }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(SkillMsg* other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
            return "protobuf.SkillMsg";
        }

    protected:
        explicit SkillMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

    public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
            kPlayerIdFieldNumber = 1,
            kSkillIdFieldNumber = 2,
        };
        // int64 player_id = 1;
        void clear_player_id();
        int64_t player_id() const;
        void set_player_id(int64_t value);

    private:
        int64_t _internal_player_id() const;
        void _internal_set_player_id(int64_t value);

    public:
        // int32 skill_id = 2;
        void clear_skill_id();
        int32_t skill_id() const;
        void set_skill_id(int32_t value);

    private:
        int32_t _internal_skill_id() const;
        void _internal_set_skill_id(int32_t value);

    public:
        // @@protoc_insertion_point(class_scope:protobuf.SkillMsg)

    private:
        class _Internal;

        template<typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
            int64_t player_id_;
            int32_t skill_id_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
            Impl_ _impl_;
        };
        friend struct ::TableStruct_Message2Server_2eproto;
    };
    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
    // PlayerMsg

    // int64 player_id = 1;
    inline void PlayerMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t PlayerMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t PlayerMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PlayerMsg.player_id)
        return _internal_player_id();
    }
    inline void PlayerMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void PlayerMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.PlayerMsg.player_id)
    }

    // .protobuf.StudentType student_type = 2;
    inline bool PlayerMsg::_internal_has_student_type() const
    {
        return job_type_case() == kStudentType;
    }
    inline bool PlayerMsg::has_student_type() const
    {
        return _internal_has_student_type();
    }
    inline void PlayerMsg::set_has_student_type()
    {
        _impl_._oneof_case_[0] = kStudentType;
    }
    inline void PlayerMsg::clear_student_type()
    {
        if (_internal_has_student_type())
        {
            _impl_.job_type_.student_type_ = 0;
            clear_has_job_type();
        }
    }
    inline ::protobuf::StudentType PlayerMsg::_internal_student_type() const
    {
        if (_internal_has_student_type())
        {
            return static_cast<::protobuf::StudentType>(_impl_.job_type_.student_type_);
        }
        return static_cast<::protobuf::StudentType>(0);
    }
    inline ::protobuf::StudentType PlayerMsg::student_type() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PlayerMsg.student_type)
        return _internal_student_type();
    }
    inline void PlayerMsg::_internal_set_student_type(::protobuf::StudentType value)
    {
        if (!_internal_has_student_type())
        {
            clear_job_type();
            set_has_student_type();
        }
        _impl_.job_type_.student_type_ = value;
    }
    inline void PlayerMsg::set_student_type(::protobuf::StudentType value)
    {
        _internal_set_student_type(value);
        // @@protoc_insertion_point(field_set:protobuf.PlayerMsg.student_type)
    }

    // .protobuf.TrickerType tricker_type = 3;
    inline bool PlayerMsg::_internal_has_tricker_type() const
    {
        return job_type_case() == kTrickerType;
    }
    inline bool PlayerMsg::has_tricker_type() const
    {
        return _internal_has_tricker_type();
    }
    inline void PlayerMsg::set_has_tricker_type()
    {
        _impl_._oneof_case_[0] = kTrickerType;
    }
    inline void PlayerMsg::clear_tricker_type()
    {
        if (_internal_has_tricker_type())
        {
            _impl_.job_type_.tricker_type_ = 0;
            clear_has_job_type();
        }
    }
    inline ::protobuf::TrickerType PlayerMsg::_internal_tricker_type() const
    {
        if (_internal_has_tricker_type())
        {
            return static_cast<::protobuf::TrickerType>(_impl_.job_type_.tricker_type_);
        }
        return static_cast<::protobuf::TrickerType>(0);
    }
    inline ::protobuf::TrickerType PlayerMsg::tricker_type() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PlayerMsg.tricker_type)
        return _internal_tricker_type();
    }
    inline void PlayerMsg::_internal_set_tricker_type(::protobuf::TrickerType value)
    {
        if (!_internal_has_tricker_type())
        {
            clear_job_type();
            set_has_tricker_type();
        }
        _impl_.job_type_.tricker_type_ = value;
    }
    inline void PlayerMsg::set_tricker_type(::protobuf::TrickerType value)
    {
        _internal_set_tricker_type(value);
        // @@protoc_insertion_point(field_set:protobuf.PlayerMsg.tricker_type)
    }

    // .protobuf.PlayerType player_type = 4;
    inline void PlayerMsg::clear_player_type()
    {
        _impl_.player_type_ = 0;
    }
    inline ::protobuf::PlayerType PlayerMsg::_internal_player_type() const
    {
        return static_cast<::protobuf::PlayerType>(_impl_.player_type_);
    }
    inline ::protobuf::PlayerType PlayerMsg::player_type() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PlayerMsg.player_type)
        return _internal_player_type();
    }
    inline void PlayerMsg::_internal_set_player_type(::protobuf::PlayerType value)
    {
        _impl_.player_type_ = value;
    }
    inline void PlayerMsg::set_player_type(::protobuf::PlayerType value)
    {
        _internal_set_player_type(value);
        // @@protoc_insertion_point(field_set:protobuf.PlayerMsg.player_type)
    }

    inline bool PlayerMsg::has_job_type() const
    {
        return job_type_case() != JOB_TYPE_NOT_SET;
    }
    inline void PlayerMsg::clear_has_job_type()
    {
        _impl_._oneof_case_[0] = JOB_TYPE_NOT_SET;
    }
    inline PlayerMsg::JobTypeCase PlayerMsg::job_type_case() const
    {
        return PlayerMsg::JobTypeCase(_impl_._oneof_case_[0]);
    }
    // -------------------------------------------------------------------

    // MoveMsg

    // int64 player_id = 1;
    inline void MoveMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t MoveMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t MoveMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.MoveMsg.player_id)
        return _internal_player_id();
    }
    inline void MoveMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void MoveMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.MoveMsg.player_id)
    }

    // double angle = 2;
    inline void MoveMsg::clear_angle()
    {
        _impl_.angle_ = 0;
    }
    inline double MoveMsg::_internal_angle() const
    {
        return _impl_.angle_;
    }
    inline double MoveMsg::angle() const
    {
        // @@protoc_insertion_point(field_get:protobuf.MoveMsg.angle)
        return _internal_angle();
    }
    inline void MoveMsg::_internal_set_angle(double value)
    {
        _impl_.angle_ = value;
    }
    inline void MoveMsg::set_angle(double value)
    {
        _internal_set_angle(value);
        // @@protoc_insertion_point(field_set:protobuf.MoveMsg.angle)
    }

    // int64 time_in_milliseconds = 3;
    inline void MoveMsg::clear_time_in_milliseconds()
    {
        _impl_.time_in_milliseconds_ = int64_t{0};
    }
    inline int64_t MoveMsg::_internal_time_in_milliseconds() const
    {
        return _impl_.time_in_milliseconds_;
    }
    inline int64_t MoveMsg::time_in_milliseconds() const
    {
        // @@protoc_insertion_point(field_get:protobuf.MoveMsg.time_in_milliseconds)
        return _internal_time_in_milliseconds();
    }
    inline void MoveMsg::_internal_set_time_in_milliseconds(int64_t value)
    {
        _impl_.time_in_milliseconds_ = value;
    }
    inline void MoveMsg::set_time_in_milliseconds(int64_t value)
    {
        _internal_set_time_in_milliseconds(value);
        // @@protoc_insertion_point(field_set:protobuf.MoveMsg.time_in_milliseconds)
    }

    // -------------------------------------------------------------------

    // PropMsg

    // int64 player_id = 1;
    inline void PropMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t PropMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t PropMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PropMsg.player_id)
        return _internal_player_id();
    }
    inline void PropMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void PropMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.PropMsg.player_id)
    }

    // .protobuf.PropType prop_type = 2;
    inline void PropMsg::clear_prop_type()
    {
        _impl_.prop_type_ = 0;
    }
    inline ::protobuf::PropType PropMsg::_internal_prop_type() const
    {
        return static_cast<::protobuf::PropType>(_impl_.prop_type_);
    }
    inline ::protobuf::PropType PropMsg::prop_type() const
    {
        // @@protoc_insertion_point(field_get:protobuf.PropMsg.prop_type)
        return _internal_prop_type();
    }
    inline void PropMsg::_internal_set_prop_type(::protobuf::PropType value)
    {
        _impl_.prop_type_ = value;
    }
    inline void PropMsg::set_prop_type(::protobuf::PropType value)
    {
        _internal_set_prop_type(value);
        // @@protoc_insertion_point(field_set:protobuf.PropMsg.prop_type)
    }

    // -------------------------------------------------------------------

    // SendMsg

    // int64 player_id = 1;
    inline void SendMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t SendMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t SendMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.SendMsg.player_id)
        return _internal_player_id();
    }
    inline void SendMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void SendMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.SendMsg.player_id)
    }

    // int64 to_player_id = 2;
    inline void SendMsg::clear_to_player_id()
    {
        _impl_.to_player_id_ = int64_t{0};
    }
    inline int64_t SendMsg::_internal_to_player_id() const
    {
        return _impl_.to_player_id_;
    }
    inline int64_t SendMsg::to_player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.SendMsg.to_player_id)
        return _internal_to_player_id();
    }
    inline void SendMsg::_internal_set_to_player_id(int64_t value)
    {
        _impl_.to_player_id_ = value;
    }
    inline void SendMsg::set_to_player_id(int64_t value)
    {
        _internal_set_to_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.SendMsg.to_player_id)
    }

    // string message = 3;
    inline void SendMsg::clear_message()
    {
        _impl_.message_.ClearToEmpty();
    }
    inline const std::string& SendMsg::message() const
    {
        // @@protoc_insertion_point(field_get:protobuf.SendMsg.message)
        return _internal_message();
    }
    template<typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE void SendMsg::set_message(ArgT0&& arg0, ArgT... args)
    {
        _impl_.message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:protobuf.SendMsg.message)
    }
    inline std::string* SendMsg::mutable_message()
    {
        std::string* _s = _internal_mutable_message();
        // @@protoc_insertion_point(field_mutable:protobuf.SendMsg.message)
        return _s;
    }
    inline const std::string& SendMsg::_internal_message() const
    {
        return _impl_.message_.Get();
    }
    inline void SendMsg::_internal_set_message(const std::string& value)
    {
        _impl_.message_.Set(value, GetArenaForAllocation());
    }
    inline std::string* SendMsg::_internal_mutable_message()
    {
        return _impl_.message_.Mutable(GetArenaForAllocation());
    }
    inline std::string* SendMsg::release_message()
    {
        // @@protoc_insertion_point(field_release:protobuf.SendMsg.message)
        return _impl_.message_.Release();
    }
    inline void SendMsg::set_allocated_message(std::string* message)
    {
        if (message != nullptr)
        {
        }
        else
        {
        }
        _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault())
        {
            _impl_.message_.Set("", GetArenaForAllocation());
        }
#endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:protobuf.SendMsg.message)
    }

    // -------------------------------------------------------------------

    // AttackMsg

    // int64 player_id = 1;
    inline void AttackMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t AttackMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t AttackMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.AttackMsg.player_id)
        return _internal_player_id();
    }
    inline void AttackMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void AttackMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.AttackMsg.player_id)
    }

    // double angle = 2;
    inline void AttackMsg::clear_angle()
    {
        _impl_.angle_ = 0;
    }
    inline double AttackMsg::_internal_angle() const
    {
        return _impl_.angle_;
    }
    inline double AttackMsg::angle() const
    {
        // @@protoc_insertion_point(field_get:protobuf.AttackMsg.angle)
        return _internal_angle();
    }
    inline void AttackMsg::_internal_set_angle(double value)
    {
        _impl_.angle_ = value;
    }
    inline void AttackMsg::set_angle(double value)
    {
        _internal_set_angle(value);
        // @@protoc_insertion_point(field_set:protobuf.AttackMsg.angle)
    }

    // -------------------------------------------------------------------

    // IDMsg

    // int64 player_id = 1;
    inline void IDMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t IDMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t IDMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.IDMsg.player_id)
        return _internal_player_id();
    }
    inline void IDMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void IDMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.IDMsg.player_id)
    }

    // -------------------------------------------------------------------

    // TreatAndRescueMsg

    // int64 player_id = 1;
    inline void TreatAndRescueMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t TreatAndRescueMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t TreatAndRescueMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.TreatAndRescueMsg.player_id)
        return _internal_player_id();
    }
    inline void TreatAndRescueMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void TreatAndRescueMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.TreatAndRescueMsg.player_id)
    }

    // int64 to_player_id = 2;
    inline void TreatAndRescueMsg::clear_to_player_id()
    {
        _impl_.to_player_id_ = int64_t{0};
    }
    inline int64_t TreatAndRescueMsg::_internal_to_player_id() const
    {
        return _impl_.to_player_id_;
    }
    inline int64_t TreatAndRescueMsg::to_player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.TreatAndRescueMsg.to_player_id)
        return _internal_to_player_id();
    }
    inline void TreatAndRescueMsg::_internal_set_to_player_id(int64_t value)
    {
        _impl_.to_player_id_ = value;
    }
    inline void TreatAndRescueMsg::set_to_player_id(int64_t value)
    {
        _internal_set_to_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.TreatAndRescueMsg.to_player_id)
    }

    // -------------------------------------------------------------------

    // SkillMsg

    // int64 player_id = 1;
    inline void SkillMsg::clear_player_id()
    {
        _impl_.player_id_ = int64_t{0};
    }
    inline int64_t SkillMsg::_internal_player_id() const
    {
        return _impl_.player_id_;
    }
    inline int64_t SkillMsg::player_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.SkillMsg.player_id)
        return _internal_player_id();
    }
    inline void SkillMsg::_internal_set_player_id(int64_t value)
    {
        _impl_.player_id_ = value;
    }
    inline void SkillMsg::set_player_id(int64_t value)
    {
        _internal_set_player_id(value);
        // @@protoc_insertion_point(field_set:protobuf.SkillMsg.player_id)
    }

    // int32 skill_id = 2;
    inline void SkillMsg::clear_skill_id()
    {
        _impl_.skill_id_ = 0;
    }
    inline int32_t SkillMsg::_internal_skill_id() const
    {
        return _impl_.skill_id_;
    }
    inline int32_t SkillMsg::skill_id() const
    {
        // @@protoc_insertion_point(field_get:protobuf.SkillMsg.skill_id)
        return _internal_skill_id();
    }
    inline void SkillMsg::_internal_set_skill_id(int32_t value)
    {
        _impl_.skill_id_ = value;
    }
    inline void SkillMsg::set_skill_id(int32_t value)
    {
        _internal_set_skill_id(value);
        // @@protoc_insertion_point(field_set:protobuf.SkillMsg.skill_id)
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // -------------------------------------------------------------------

    // @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Message2Server_2eproto
